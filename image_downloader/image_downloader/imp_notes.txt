
________________________________________EXPLANATION OF put_text_on_video() FUNCTION____________________________________________________________________________________

 #step1:  These lines just find out the starting frame and ending frame for timestamp
 current_timestamp = timestamps.pop(0)
  Explaination: first time it retrieves first element then removes it from list..next time a new first element is retrieved and so on
_______________________________________________________________________________________________________________________________
 current_timestamp["start_frame"] = int(current_timestamp["start_time"] * fps)
                print(f"fps: {fps}, start_time: {current_timestamp['start_time']} and start_frame {current_timestamp['start_frame']} ")
                current_timestamp["end_frame"] = int(current_timestamp["end_time"] * fps)
                print(f"fps: {fps}, start_time: {current_timestamp['end_time']} and end_frame {current_timestamp['end_frame']}\n\n")

NOTE: by doing current_timestamp['start_frame']  we are just defining key of dictionary and value is   int(current_timestamp["start_time"] * fps)


so basically to the point we know the fps rate and start time ...but the main point is that we don't know the start_frame where we need to make changes(put timestamp)
so to retrieve it there is a formula  :[  fps * start_time  = start_frame ]

fps: 24.0, start_time: 2.0 and new 48
fps: 24.0, start_time: 4.0 and new 96
fps: 24.0, start_time: 6.0 and new 144
fps: 24.0, start_time: 8.0 and new 192
fps: 24.0, start_time: 10.0 and new 240    so for example fps was 24 and start time was 2 so by multiplying we get 48 which means change will occur at 48th frame
and similarly the end frame
___________________________________________________________________________________________________________________________________________________

# step2: from this point, it ...actually starts the process of adding timestampe because now it has all the
        # requirements for adding a time stamp which are
        # start frame and end frame
        # Add timestamp to the frame
        if current_timestamp and frame_count >= current_timestamp["start_frame"]:
            add_timestamp(frame, current_timestamp["text"], **text_properties)def put_text_on_video(video_path, output_path, text_properties):
    # Open the video file
    video = cv2.VideoCapture(video_path)  # videoCapture() converts it into a video object so all func like pause resume play can be applied to this video

    # Get video properties using get() func:  get() has some pre-defined attributes that when passed as arguments, it returns their value
    fps = video.get(cv2.CAP_PROP_FPS)
    frame_width = int(video.get(cv2.CAP_PROP_FRAME_WIDTH))
    frame_height = int(video.get(cv2.CAP_PROP_FRAME_HEIGHT))

    # Create a VideoWriter object to save the output video
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')  # * is used in unpacking iterables so, *'mp4v' is easy way to pass. the other way is separately passing 4 characters like 'm','p','4','v'
    output_video = cv2.VideoWriter(output_path, fourcc, fps, (frame_width, frame_height)) # it makes an empty video continer with the specified name and path for the video
    # ...and the following code keeps modifying each frame and storing in it


    actual =arrange()   # arranges  items in reverse order for 5 4 3 2 1  type of video

    timestamps = [
        {"text": f"5. {actual[1]}", "start_time": 2.0, "end_time": 4.0},
        {"text": f"4. {actual[2]}", "start_time": 4.0, "end_time": 6.0},
        {"text": f"3. {actual[3]}", "start_time": 6.0, "end_time": 8.0},
        {"text": f"2. {actual[4]}", "start_time": 8.0, "end_time": 10.0},
        {"text": f"1. {actual[5]}", "start_time": 10.0, "end_time": 12.0},
    ]
    # Read and process each frame of the video
    frame_count = 0
    current_timestamp = None

    while video.isOpened():
        ret, frame = video.read()
        if not ret:
            break

        #step1:  These lines just find out the starting frame and ending frame for timestamp
        if current_timestamp is None or frame_count >= current_timestamp["end_frame"]:  # initially the first condition =None is true then each time frame_count>= true ... it goes inside and add a new timestamp
            # Get the next timestamp
            if timestamps:   # means  if timestamps list isn't empty

                current_timestamp = timestamps.pop(0)  # first time it retrieves first element then removes it from list..next time a new first element is retrieved and so on
                current_timestamp["start_frame"] = int(current_timestamp["start_time"] * fps) # we have fps: 24 and start_time: but to put time_stamp on current location we need start_frame so for that : fps* start_time= start_frame
                current_timestamp["end_frame"] = int(current_timestamp["end_time"] * fps)  # similarly for end_frame : end_time* fps


        # step2: from this point, it ...actually starts the process of adding timestampe because now it has all the
        # requirements for adding a time stamp which are
        # start frame and end frame
        # Add timestamp to the frame

        if current_timestamp and frame_count >= current_timestamp["start_frame"]:  # this line checks two conditions that "current_timestamp" isn't empty and that start_frame is greater than frame_count ...and then it adds timestamp
            add_timestamp(frame, current_timestamp["text"], **text_properties)

        # Write the frame with added text to the output video
        output_video.write(frame)

        # Display the resulting frame (optional)
        cv2.imshow("Frame", frame)
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

        frame_count += 1


#____-----------------------------------------------------------------------------------------------------------------------
Final Explanation:
The function starts by locating the input video and converting it into an editable form using the VideoCapture() function. This allows us to perform various operations on the video, such as reading frames and modifying them.

It retrieves important information about the video using the get() function of the VideoCapture class. This includes the frames per second (fps), frame width, and frame height. These details are necessary for further processing.

Next, it defines an important parameter called fourcc, which stands for "four character code". This code represents the video format or codec used for encoding the video. In this case, it is set to 'mp4v', indicating the MPEG-4 Video codec. The fourcc value is used later when creating the output video file.

The function creates an empty video container using the VideoWriter() function. This container will store the modified frames. It takes the following arguments:

output_path: The path where the output video file will be saved.
fourcc: The video format or codec to be used.
fps: The frames per second of the output video.
(frame_width, frame_height): The width and height of the video frames.
By creating this video container, we are ready to add the modified frames one by one.

The function then prepares the content to be displayed as timestamps. It arranges the items in reverse order and stores them in the actual list.

The function creates a list of dictionaries called timestamps. Each dictionary represents a timestamp with the following details:

"text": The content of the timestamp, which includes the item from the actual list.
"start_time": The start time of the timestamp in seconds.
"end_time": The end time of the timestamp in seconds.
These timestamps will be used to determine when and what text should be added to the video frames.

The function enters a while loop, which runs as long as the video is open and frames are available to read.

Within the loop, it reads each frame of the video using the video.read() function. The returned value ret indicates whether a frame was successfully read. If ret is False, it means there are no more frames to read, and the loop breaks.

If a frame is successfully read, the function checks if it's time to display a timestamp. This is determined by comparing the frame_count with the start_frame of the current timestamp.

The purpose of the start_frame and end_frame is to define the range of frames within which a specific timestamp should be displayed. By using frames instead of seconds, we ensure that the timestamps are aligned accurately with the video frames.
When it's time to display a timestamp, the function calls the add_timestamp() function, passing the current frame, the text of the timestamp, and the text_properties as arguments. This function adds the timestamp text to the frame based on the provided properties, such as font color.

After adding the timestamp, the modified frame is written to the output video using the output_video.write(frame) function. This step ensures that each frame, including those with the added timestamp, is saved to the output video file.

Optionally, the function displays the resulting frame using cv2.imshow("Frame", frame) and waits for a key press. If the 'q' key is pressed, the loop breaks and the function exits.

The frame_count variable is incremented to keep track of the number of frames processed.

Once all frames have been processed, the function releases the video capture and writer objects using the video.release() and output_video.release() functions. This frees up system resources associated with these objects.

Finally, the function destroys all OpenCV windows that were created during the execution of the program using the cv2.destroyAllWindows() function.

By following this step-by-step process, the put_text_on_video function locates the video, extracts necessary information, prepares timestamps, adds them to the frames, and saves the modified video with timestamps to the specified output path.





________________________________________FULL EXPLANATION OF add_timestamp() FUNCTION__________________________________________

if i  am doing this
def add_timestamp(frame, text, font=cv2.FONT_HERSHEY_SCRIPT_SIMPLEX, font_scale=1, color=(0, 255, 0),
                  thickness=2, offset=(0, 0), line_type=cv2.LINE_AA):

then there is no reason for passing **textproperties ( **kwargs)
add_timestamp(frame, current_timestamp["text"], **text_properties)

because it is only using pre-defined(default) values
so  i can simply do:

def add_timestamp(frame, text, font=cv2.FONT_HERSHEY_SCRIPT_SIMPLEX, font_scale=1, color=(0, 255, 0),
                  thickness=2, offset=(0, 0), line_type=cv2.LINE_AA):

add_timestamp(frame, current_timestamp["text"])   # removed **text_properties because was not needed


or if i want to use then there are two ways


Method 1:  using find value by key  method like   text_properties['font'] returns value  font

def add_timestamp(text, frame, **text_properties):
    # Access individual properties
    font = text_properties["font"]
    font_scale = text_properties["font_scale"]
    color = text_properties["color"]
    thickness = text_properties["thickness"]
    offset = text_properties["offset"]
    line_type = text_properties["line_type"]

    # Rest of the function implementation...

# Calling the function
add_timestamp(current_timestamp["text"], frame, **text_properties)


good news: now it is getting all values from the text_properties
bad news: if there are no values it will give error

___________________________________________________
Method 2: using get() function

def add_timestamp(text, frame, **text_properties):
    # Access individual properties
    font = text_properties.get("font", cv2.FONT_HERSHEY_SIMPLEX)
    font_scale = text_properties.get("font_scale", 1.5)
    color = text_properties.get("color", (0, 0, 255))
    thickness = text_properties.get("thickness", 2)
    offset = text_properties.get("offset", (0, 0))
    line_type = text_properties.get("line_type", cv2.LINE_AA)

    # Rest of the function implementation...

# Calling the function
add_timestamp(current_timestamp["text"], frame, **text_properties)


good news: it is also getting all value from text_properties
bad news : there is no bad news ... the second argument of get() is default values for all in case user doesn't provide any value



_________________________________________________________________________________________
custom implementation of  wrap()  ...so that text is wrapped into multiple lines

    #SUMMARY: this part just makes a list(wrapped_lines) of strings :
    # 1. len of list is total number of wrapped lines
    # 2. And Each string represents text on each line

    wrapped_lines = []
    words = text.split(' ')
    current_line = ''
    for word in words:
        (line_width, _), _ = cv2.getTextSize(current_line + ' ' + word, font, font_scale, thickness)
        if line_width <= frame_width:
            current_line += ' ' + word
        else:
            wrapped_lines.append(current_line.strip())
            current_line = word

    if current_line:
        wrapped_lines.append(current_line.strip())

    #to this point list of splitted text is returned means if text was wrapped into 3 lines then this list will have 3 elements

__________________________________________________________________________________
getTextSize()

so basically getTextSize() function takes  "Text(content), "fontScale(size of text)","font( type of font)  and thickness  )
 and based on these inputs returns text height and width ...means how would it look like when placed on screen

formal explanation:
The cv2.getTextSize() function takes the text content, font scale, font type, and thickness as inputs and
returns the width and height of the rendered text. By using cv2.getTextSize(), you can determine how the text
would look when placed on a screen or an image. The returned width and height values represent the dimensions
of the rendered text in pixels

#_------------------------------------------------------------------------------------------------------
SUMMMARY: these lines are just finding  text,width,text_height and line spacing of text on screen
(text_width, text_height), _ = cv2.getTextSize(text, font, font_scale, thickness)
line_spacing = int(text_height * 1.5)

The use of _ as a variable name is a common convention in Python to indicate that a value is
 being received but intentionally discarded. It is often used when you are only interested in
  certain elements of a tuple, list, or other iterable and don't plan to use the discarded value
   further in your code.

 (text_width, text_height), _ = cv2.getTextSize(text, font, font_scale, thickness)
 #so basically getTextSize() function takes  "Text(content), "fontScale(size of text)","font( type of font)  and thickness  )
  and based on these inputs returns text height and width ...means how would it look like when placed on screen and also
   it returns another thing baseline offset that we don't need so we ignore it by storing it in "_" that is a convention
#_______________________________________________________________________________________________________________

# SUMMARY: Calculates where exactly text is placed vertically( y-axis)  by performing following calculations  # not actually drawing
    y = int((frame_height + text_height) / 2)  # first it adds frame_height(the full screen) and text_height and divides it by 2 to find midpoint
    y= y+ offset[1]  # then for further up and down of text positioning it adds offset[1] which is height if it is a positive number text goes down, else up
    y = y - (len(wrapped_lines) * line_spacing) # as the number of lines maybe more, we multiply [spacing height * total lines] which will help us take text upward and more place for down lines
    # so  basically y - (len(wrapped_lines) * line_height) this line kind acts as a negative offset value


#_____________________________________________________________________________________________________________________
# SUMMARY: this part is where the text is actually is drawn on screen
    for textLine in wrapped_lines: # wrapped_lines is just a list of strings mentioned above
        (textline_width, _), _ = cv2.getTextSize(textLine, font, font_scale, thickness)  # we know get size returns width,height and baseline offset and in this case we just need width so using "_" convention to discard others
        x = int((frame_width - textline_width) / 2) + offset[0] # this line is calculating where exactly the text is placed horizontally (x-axis)

        cv2.putText(frame, textLine, (x, y), font, font_scale, color, thickness, line_type) # and finally this function draws text on video by taking follwing arguments: 1. frame(screen/full_image)  2. textline(put this func in loop if more than one lines)3. (x,y) coordinates that we calculated above.  and the other text properties like font, thickness etc and finally draws the text
        y += line_spacing  # and after text is placed on first line ...next it decides the position of next line by adding "line_spacing to y
        # in other words we can say that  in next line coordinates in putText()-> (x,y) == ( x, y+line_spacing)


